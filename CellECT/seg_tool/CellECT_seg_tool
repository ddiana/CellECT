#!/usr/bin/env python

# Author: Diana Delibaltov
# Vision Research Lab, University of California Santa Barbara

# Module information
import CellECT.seg_tool.module_info

# Imports
import pdb
import numpy as np
import scipy.io as spio
from PyML import VectorDataSet
import sys
from termcolor import colored
import os
import time
import logging
import datetime
from optparse import OptionParser

## memory inspection tool
#from memory_profiler import profile


# Imports from this project
from CellECT.seg_tool.seg_io import load_parameters as loader
from CellECT.seg_tool.cellness_metric import cellness_classifier as cellness
from CellECT.seg_tool.seg_io import load_all
from CellECT.seg_tool.nuclei_collection import nuclei_collection as nc
from CellECT.seg_tool.seed_segment_collection import seed_segment_collection as ssc
from CellECT.seg_tool.seed_collection import seed_collection as seedc
from CellECT.seg_tool.features import segment_features as feat
from CellECT.seg_tool.seg_utils import call_silent
from CellECT.seg_tool.seg_io import save_all
from CellECT.seg_tool.seg_utils import labelmap_tools as lm_tools
from CellECT.seg_tool.run_watershed import run_watershed as ws




import CellECT.seg_tool.globals


"""
Main sequence of events of the seg_tool, the interactive segmentation tool 
from the CellECT (Cell Evolution Capturing Tool) project.
"""


def setup_logging():

	logging.basicConfig(filename='CellECT_seg_tool.log', level=logging.INFO)
	message = " =============================== Starting CellECT_seg_tool ============================================"
	logging.info (message)
	logging.info('Started at %s' % datetime.datetime.now().strftime("%Y-%m-%d %H:%M") )


def ask_for_config_file():

	print colored("Please provide location of configuration file.", "red")
	import Tkinter, tkFileDialog

	root = Tkinter.Tk()
	root.withdraw()
	file_path = tkFileDialog.askopenfilename()
	root.destroy()

	return file_path




def parse_input():



	parser = OptionParser()
	parser.add_option("-f", "--config_file", dest="filename", help="Specify configuration file.", default="", metavar="FILE")
	parser.add_option("-i", "--no_interactive", action="store_true", dest="no_interactive", default=False, help="Ask user for feedback.")
	parser.add_option("-m", "--no_cellness_metric", action="store_true", dest="no_cellness_metric", default=False, help="Predict bad segments.")
	parser.add_option("-b", "--bisque", action="store_true", dest="bisque", default=False, help="Run on bisque server.")

	(options, args) = parser.parse_args()

	CellECT.seg_tool.globals.DEFAULT_PARAMETER["no_interactive"] = options.no_interactive
	CellECT.seg_tool.globals.DEFAULT_PARAMETER["no_cellness_metric"] = options.no_cellness_metric
	CellECT.seg_tool.globals.DEFAULT_PARAMETER["bisque"] = options.bisque

	if options.filename == "":
		config_file_path = ask_for_config_file()
	else:
		config_file_path = options.filename
	return config_file_path


	
#@profile
def main():


	setup_logging()
	
	config_file_path = parse_input()

	## READ AND SET PARAMETERS #################################################
	
	print "Loading config parameters..."
	loader.read_program_parameters(config_file_path)

	## LOADING TRAINING DATA AND TRAINING CLASSIFIER ###########################


	if not CellECT.seg_tool.globals.DEFAULT_PARAMETER["no_cellness_metric"]:

		print colored("================================================================================",'red')
		print colored("              Loading training data and training cellness metric:", 'red')
		print colored("================================================================================",'red')
	
		classifier = cellness.learn_classifier()


	## LOADING DATA FOR CURRENT VOLUME #########################################
	
	print colored("================================================================================",'red')
	print colored("                            Processing test volume:",'red')
	print colored("================================================================================",'red')
	
	print "Loading test volume..."
	vol = load_all.load_from_mat(CellECT.seg_tool.globals.DEFAULT_PARAMETER["volume_mat_path"], CellECT.seg_tool.globals.DEFAULT_PARAMETER["volume_mat_var"])
	

	#watershed = shuffle_labels(watershed)

	print "Loading nuclei..."
	nuclei_collection = nc.NucleusCollection(CellECT.seg_tool.globals.DEFAULT_PARAMETER["nuclei_mat_path"], CellECT.seg_tool.globals.DEFAULT_PARAMETER["nuclei_mat_var"])
	seed_collection = seedc.SeedCollection([])

	print "Loading initial segmentation if any..."
	try:
		watershed = load_all.load_from_mat(CellECT.seg_tool.globals.DEFAULT_PARAMETER["first_seg_mat_path"], CellECT.seg_tool.globals.DEFAULT_PARAMETER["first_seg_mat_var"])
	except:
		print "No initial segmentation found... Making initial segmentation."
		# input pts
		init_pts = ws.make_list_of_input_points(nuclei_collection, seed_collection)
		# make first seg
		watershed = ws.run_watershed(vol, init_pts)
		# save it so that it does not need to be computed again
		spio.savemat(CellECT.seg_tool.globals.DEFAULT_PARAMETER["first_seg_mat_path"], { CellECT.seg_tool.globals.DEFAULT_PARAMETER["first_seg_mat_var"]: watershed})

	last_length_of_seeds_list = 0 
	
	seed_segment_collection = ssc.SeedSegmentCollection()


	ask_feedback = True
	watershed_old = watershed

	CellECT.seg_tool.globals.should_load_last_save
	CellECT.seg_tool.globals.should_load_last_save = False

	
	## MAIN LOOP ###############################################################
	sum_new = None



	while ask_feedback or CellECT.seg_tool.globals.should_load_last_save:


		## Load last save, or continue with current setup ######################
		if CellECT.seg_tool.globals.should_load_last_save:
			nuclei_collection, seed_collection, watershed = load_all.load_last_save()
			seed_segment_collection.update_seed_segment_collection(seed_segment_collection, watershed, seed_collection)
			#watershed = recolor_label_map_correctly (watershed, nuclei_collection, seed_collection, collection_of_ws_segments, seed_segment_collection)
	
			CellECT.seg_tool.globals.should_load_last_save = False


		## Prepare cellness metric #############################################

		print "Preparing data for classifier..."

		set_of_labels = set(int(x) for x in np.unique(watershed) if x > 1)	
		original_init_pts = ws.make_list_of_input_points(nuclei_collection)


		collection_of_ws_segments = feat.get_segments_with_features(vol, watershed, set_of_labels, "watershed", nuclei_collection)
		test_data = cellness.prepare_test_data(collection_of_ws_segments)

		## Apply cellness metric ###############################################

		if not 	CellECT.seg_tool.globals.DEFAULT_PARAMETER["no_cellness_metric"]:

			
			test_data_svm = call_silent.call_silent_process(VectorDataSet, test_data)

			print "Applying cellness metric to segments..."
			class_prediction, discriminant_value = cellness.classify_segments(classifier,test_data_svm)

			classified_segments = (set_of_labels, class_prediction, discriminant_value)

		else:

			class_prediction = [0 for i in xrange(len(set_of_labels))]
			discriminant_value = [1 for i in xrange(len(set_of_labels))]
			classified_segments = (set_of_labels, class_prediction, discriminant_value)



		## ASK FOR FEEDBACK ####################################################

		print "Prompting user for feedback..."	


		if CellECT.seg_tool.globals.DEFAULT_PARAMETER["bisque"]:
			# TODO: bisque UI

			from CellECT.seg_tool.bisque.bisque_io import segments_xml
			from CellECT.seg_tool.bisque.bisque_io import talk_to_ui

			print colored("BISQUE UI","red")
			logging.info("BISQUE UI.")
			talk_to_ui.wait_for_UI_update()

		all_user_feedback = []


		if not CellECT.seg_tool.globals.DEFAULT_PARAMETER["no_interactive"]:

			if CellECT.seg_tool.globals.DEFAULT_PARAMETER["bisque"]:
				# TODO: bisque UI
				from CellECT.seg_tool.bisque.bisque_io import segments_xml
				from CellECT.seg_tool.bisque.bisque_io import talk_to_ui
				print colored("BISQUE UI","red")
				logging.info("BISQUE UI.")
				talk_to_ui.wait_for_UI_update()

			else:
				import pylab
				from CellECT.seg_tool.gui import main_gui
				from CellECT.seg_tool.gui import parse_feedback as gui_parse
				from CellECT.seg_tool.seg_utils import display_tools
				logging.info("DESKTOP CLIENT ")
				all_user_feedback = main_gui.show_uncertainty_map_and_get_feedback( vol, watershed, collection_of_ws_segments, classified_segments, nuclei_collection, seed_collection, seed_segment_collection, watershed_old)
	



		## USE FEEDBACK ########################################################

		if not CellECT.seg_tool.globals.should_load_last_save:

			print "Processing user feedback..."
			old_number_of_nuclei = len(nuclei_collection.nuclei_list)
			old_number_of_seeds = len(seed_collection.list_of_seeds)
		
			if not CellECT.seg_tool.globals.DEFAULT_PARAMETER["no_interactive"]:
				# Get feedback #####################################################
				if CellECT.seg_tool.globals.DEFAULT_PARAMETER["bisque"]:
					# TODO: bisque UI parser
					print colored("BISQUE UI PARSER","red")
					logging.info("BISQUE UI PARSER.")
				else:
					logging.info("DESKTOP CLIENT UI PARSER.")
					gui_parse.parse_user_feedback(watershed, nuclei_collection, collection_of_ws_segments, seed_collection, all_user_feedback)	

		
			new_number_of_nuclei = len(nuclei_collection.nuclei_list)
			new_number_of_seeds = len(seed_collection.list_of_seeds)

			## Apply Feedback ##################################################
	
			if len(all_user_feedback):

				init_pts = ws.make_list_of_input_points(nuclei_collection, seed_collection)
				#call_silent_err( show_new_user_points,original_init_pts, init_pts)

				watershed_old = watershed

				## Rerun Watershed if necessary ################################
				if old_number_of_nuclei != new_number_of_nuclei or old_number_of_seeds != new_number_of_seeds:
				
					watershed = ws.run_watershed(vol, init_pts)
					seed_segment_collection.update_seed_segment_collection(seed_segment_collection, watershed, seed_collection)


				watershed = lm_tools.recolor_label_map_correctly (watershed, nuclei_collection, seed_collection, collection_of_ws_segments, seed_segment_collection)


			else:
				ask_feedback = False


			
	## Show final output #######################################################
	if not CellECT.seg_tool.globals.DEFAULT_PARAMETER["no_interactive"]:
		if not CellECT.seg_tool.globals.DEFAULT_PARAMETER["bisque"]:
			display_tools.display_volume_two(vol, watershed)
		else:
			logging.info("Not displaying final volume (bisque).")


	## Ask if save #############################################################
	should_save = ""
	if CellECT.seg_tool.globals.DEFAULT_PARAMETER["bisque"]:
		should_save = "y"
		logging.info("Not prompting user for saving (bisque).")
		CellECT.seg_tool.bisque.bisque_io.segments_xml.write_bisque_segments_xml(nuclei_collection, seed_collection, collection_of_ws_segments, seed_segment_collection, watershed)
	elif CellECT.seg_tool.globals.DEFAULT_PARAMETER["no_interactive"]:
		should_save = "y"
	else:
		while not should_save in set(['y', 'n']):
			print colored("Save latest result? [Y/N] ","red")
			should_save = sys.stdin.read(1)
			should_save = should_save.lower()
			print ""


	## Save ####################################################################

	if should_save.lower() == "y":
		save_all.save_current_status(nuclei_collection, seed_collection, collection_of_ws_segments, seed_segment_collection, watershed)
	else:
		print "Not saving."
	
	logging.info('Exitted normally at %s' % datetime.datetime.now().strftime("%Y-%m-%d %H:%M") )
	print "KTnxBye."





if __name__ == "__main__":





	main()




