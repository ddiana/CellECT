import numpy as np
from scipy import io
import pdb

from PyML import VectorDataSet
from PyML.classifiers.svm import SVM, loadSVM
from matplotlib.widgets import Slider
from PyML.classifiers.svm import loadSVM

import sys


from termcolor import colored


import os





# Module Information.
__version__     = "0.01"
__author__      = "Diana Delibaltov"
__url__         = "http://ece.ucsb.edu/~diana, http://vision.ece.ucsb.edu"
__copyright__   = "(c) 2013 Diana Delibaltov, Vision Research Lab, UCSB"
__license__     = "UCSB License"
__description__ = "Cell segmentation tool for confocal microscopy membrane/nuclei images. Works with cell_tracker.py."





########## globals:

DEFAULT_PARAMETER = {}

CONFIG_FILE_PATH = "config_file.cnf"

_mean_per_dim = []
_std_per_dim = []


















	
	
def make_list_of_input_points(nuclei_collection, seed_collection = None):

	len_nuclei = len(nuclei_collection.nuclei_list)
	try:
		len_seeds = len(seed_collection.list_of_seeds)
	except:
		len_seeds = 0
	init_pts = np.zeros((3, len_nuclei + len_seeds))
	
	counter = 0
	for nucleus in nuclei_collection.nuclei_list:
		init_pts[:,counter] = (nucleus.x, nucleus.y, nucleus.z)
		counter += 1
		
	if seed_collection:
		for seed in seed_collection.list_of_seeds:
			init_pts[:,counter] = (seed.x, seed.y, seed.z)
			counter += 1
		
	return init_pts
		
	
	
def run_watershed(vol, init_pts):

	
	print "\nRunning seeded watershed....\n"
	has_bg = int(DEFAULT_PARAMETER["has_bg"])
	io.savemat("temp/watershed_input.mat", {"vol":vol, "seeds": init_pts, "has_bg": has_bg})
	import subprocess
	import os
	t = time.time()
	
	os.system( "matlab -nodesktop -nosplash -r \"cd utils; run_seeded_watershed('../temp/watershed_input.mat', '../temp/watershed_result.mat')\"")
	os.system("stty echo")

		
	print ".......", time.time() - t, "sec"
	
	ws = io.loadmat("temp/watershed_result.mat")["ws"]
	return ws






	
#def get_cellness_for_specific_labels(uncertainty_map, segment_collection):
#	
#	labels =[137.0, 180.0, 282.0, 112.0, 281.0, 170.0, 279.0, 275.0, 136.0, 246.0, 119.0, 273.0, 290.0, 152.0, 40.0, 80.0, 91.0, 12.0, 240.0, 156.0, 287.0, 120.0, 139.0, 158.0, 284.0, 155.0, 182.0, 118.0, 261.0, 244.0, 286.0, 292.0, 169.0, 167.0, 135.0, 95.0, 126.0, 127.0, 124.0, 123.0, 125.0, 109.0, 242.0, 233.0, 145.0, 277.0, 268.0, 165.0, 189.0, 154.0]

#	f_meas = [0.74247945173495011, 0.74594890137199088, 0.90343904062635039, 0.48555565894183028, 0.88846572655285871, 0.87073551115488934, 0.87956315693728826, 0.90229298241629086, 0.8611897266946037, 0.91636015611815946, 0.81496061759522676, 0.90549732946950956, 0.91349230876978349, 0.77653479862343244, 0.70464012861413494, 0.88650874659949352, 0.58081174934154134, 0.84046257327520801, 0.926278247329826, 0.8276489468492505, 0.89664466362299877, 0.78090300918904865, 0.83505784759760215, 0.86577054945458121, 0.8194330568081547, 0.89772757174374418, 0.85617735237927095, 0.75222859228031447, 0.8444957510153086, 0.6163141872407446, 0.90083887247643679, 0.84604818889297551, 0.82462810071046677, 0.76633901523811943, 0.86704669174258109, 0.74878339762670476, 0.79437821547153931, 0.78173288597164015, 0.8620762048347349, 0.81376202674466624, 0.83552562331692271, 0.77697344253782186, 0.89688513224998401, 0.90093469563838557, 0.78475625998393184, 0.88192461450599657, 0.89298298786375574, 0.86647289745106659, 0.91429510321240348, 0.76808278224057625]

#	cellness_measure = []
#	for label in labels:
#		seg_index = segment_collection.segment_label_to_list_index_dict[label]
#		segment = segment_collection.list_of_segments[seg_index]
#		a_voxel = segment.list_of_voxel_tuples[0]
#		cellness_measure.append(uncertainty_map[a_voxel])

##pylab.figure()
##pylab.plot(cellness, "--r", linewidth = 3, label= "Cellness")
##pylab.hold(True)
##pylab.plot(f_meas, "b", linewidth = 3, label= "F-measure")
##pylab.xlabel("Cell index")
##pylab.legend()
##pylab.show()

#	return cellness_measure	

	


def init():


	if len(sys.argv) != 2:
		print "Usage: python interactive_seg.py PATH_TO_CONFIG_FILE"
		return
	else:
		global CONFIG_FILE_PATH
		CONFIG_FILE_PATH = sys.argv[1]



	if not os.path.exists("temp"):
		os.makedirs("temp")

	##############################################################
	# READ AND SET PARAMETERS
	
	print "Loading config parameters..."
	read_program_parameters()


	##############################################################
	# LOADING TRAINING DATA AND TRAINING CLASSIFIER

	print colored("================================================================================",'red')
	print colored("              Loading training data and training cellness metric:", 'red')
	print colored("================================================================================",'red')
	
	classifier = learn_classifier()


	##############################################################
	# LOADING DATA FOR CURRENT VOLUME
	
	print colored("================================================================================",'red')
	print colored("                            Processing test volume:",'red')
	print colored("================================================================================",'red')
	
	print "Loading test volume..."
	vol = load_from_mat(DEFAULT_PARAMETER["volume_mat_path"], DEFAULT_PARAMETER["volume_mat_var"])
	print "Loading initial segmentation..."
	watershed = load_from_mat(DEFAULT_PARAMETER["first_seg_mat_path"], DEFAULT_PARAMETER["first_seg_mat_var"])

	#watershed = shuffle_labels(watershed)

	



	print "Loading nuclei..."
	nuclei_collection = NucleusCollection(DEFAULT_PARAMETER["nuclei_mat_path"], DEFAULT_PARAMETER["nuclei_mat_var"])

	last_length_of_seeds_list = 0 
	seed_collection = SeedCollection([])
	seed_segment_collection = SeedSegmentCollection()


	ask_feedback = True
	watershed_old = watershed

	global should_load_last_save
	should_load_last_save = False

	while ask_feedback or should_load_last_save:

		if should_load_last_save:
			nuclei_collection, seed_collection, watershed = load_last_save()
			seed_segment_collection.update_seed_segment_collection(seed_segment_collection, watershed, seed_collection)
			#watershed = recolor_label_map_correctly (watershed, nuclei_collection, seed_collection, collection_of_ws_segments, seed_segment_collection)
	
			should_load_last_save = False


		print "Preparing data for classifier..."

		set_of_labels = set(int(x) for x in np.unique(watershed) if x > 1)	
		original_init_pts = make_list_of_input_points(nuclei_collection)
		collection_of_ws_segments = get_segments_with_features(vol, watershed, set_of_labels, "watershed", nuclei_collection)

		test_data = prepare_test_data(collection_of_ws_segments)
		test_data_svm = call_silent_process(VectorDataSet, test_data)

		print "Applying cellness metric to segments..."
		class_prediction, discriminant_value = classify_segments(classifier,test_data_svm)

		classified_segments = (set_of_labels, class_prediction, discriminant_value)

		print "Prompting user for feedback..."	
		all_user_feedback = call_silent_err(show_uncertainty_map_and_get_feedback, vol, watershed, collection_of_ws_segments, classified_segments, nuclei_collection, seed_collection, seed_segment_collection, watershed_old)
	
		if not should_load_last_save:

			print "Processing user feedback..."
			old_number_of_nuclei = len(nuclei_collection.nuclei_list)
			old_number_of_seeds = len(seed_collection.list_of_seeds)
		
			parse_user_feedback(watershed, nuclei_collection, collection_of_ws_segments, seed_collection, all_user_feedback)	
		
			new_number_of_nuclei = len(nuclei_collection.nuclei_list)
			new_number_of_seeds = len(seed_collection.list_of_seeds)
	
			if len(all_user_feedback):

				init_pts = make_list_of_input_points(nuclei_collection, seed_collection)
				#call_silent_err( show_new_user_points,original_init_pts, init_pts)

				watershed_old = watershed
				if old_number_of_nuclei != new_number_of_nuclei or old_number_of_seeds != new_number_of_seeds:
				
					watershed = run_watershed(vol, init_pts)
					seed_segment_collection.update_seed_segment_collection(seed_segment_collection, watershed, seed_collection)

				watershed = recolor_label_map_correctly (watershed, nuclei_collection, seed_collection, collection_of_ws_segments, seed_segment_collection)

				del test_data
				del test_data_svm
				del classified_segments
				del all_user_feedback
				del init_pts
			
			else:
				ask_feedback = False


			

	display_volume_two(vol, watershed)


	should_save = ""
	while not should_save in set(['y', 'n']):
		print colored("Save latest result? [Y/N] ","red")
		should_save = sys.stdin.read(1)
		should_save = should_save.lower()
		print ""

		

	if should_save.lower() == "y":
		save_current_status(nuclei_collection, seed_collection, collection_of_ws_segments, seed_segment_collection, watershed)
	else:
		print "Not saving."
	

	print "KTnxBye."

if __name__ == "__main__":


	init()



